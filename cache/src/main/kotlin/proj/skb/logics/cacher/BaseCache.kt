package proj.skb.logics.cacher

import proj.skb.ProjSkbConstants
import proj.skb.ProjSkbConstants.STUB_GET_FAIL
import proj.skb.ProjSkbConstants.STUB_GET_NOT_FOUND
import proj.skb.ProjSkbConstants.STUB_GET_OK
import proj.skb.common.CacheObject
import proj.skb.common.CacheStatus
import proj.skb.common.ICacheContext
import proj.skb.common.ISkbCache
import proj.skb.exceptions.StubGeneratedException
import java.time.Duration
import java.util.*

abstract class BaseCache(
    val defatulDelay: Duration = Duration.parse(ProjSkbConstants.DEFAULT_DELAY),
    val maxDelay: Duration = Duration.parse(ProjSkbConstants.DEFAULT_MAX_DELAY),
    val minDelay: Duration = Duration.parse(ProjSkbConstants.DEFAULT_MIN_DELAY),
    val allowedQueues: Collection<String> = ProjSkbConstants.DEFAULT_ALLOWED_QUEUES
): ISkbCache {

    protected abstract fun saveInCache(key: String, value: CacheObject)
    protected abstract fun getFromCache(key: String): CacheObject?
    protected abstract fun checkInCache(key: String): Boolean

    override fun setValue(cacheObject: CacheObject): ICacheContext = SkbCacheContext().apply {
        val id = UUID.randomUUID().toString()
        this.id = id
        obj = cacheObject.takeIf { it.delay != Duration.ZERO } ?: cacheObject.copy(delay = defatulDelay)
        if (! validate(this)) return@apply
        try {
            saveInCache(id, cacheObject)
            status = CacheStatus.OK
        } catch (e: Throwable) {
            status = CacheStatus.FAIL
            errorMessage = e.message ?: "Error setting value"
        }
    }

    override fun contains(context: ICacheContext): ICacheContext = try {
        val isFound = checkInCache(context.id)
        SkbCacheContext(
            id = context.id,
            status = if (isFound) CacheStatus.OK else CacheStatus.NOT_FOUND
        )
    } catch (e: Throwable) {
        SkbCacheContext(
            id = context.id,
            status = CacheStatus.FAIL,
            errorMessage = e.message ?: "Error checking existence"
        )
    }

    override fun getValue(context: ICacheContext) = SkbCacheContext().apply {
        id = context.id
        stub = context.stub

        val cacheObject = try {
            if (stubForGet(this)) return@apply
            else getFromCache(context.id)
        } catch (e: Throwable) {
            obj = CacheObject.NONE
            status = CacheStatus.FAIL
            errorMessage = e.message ?: "Error in getValue"
            return@apply
        }

        cacheObject?.also {
            obj = it
            status = CacheStatus.OK
        } ?: run {
            obj = CacheObject.NONE
            status = CacheStatus.NOT_FOUND
        }
    }

    private fun validate(context: SkbCacheContext): Boolean = with(context) {
        when {
            obj.delay < minDelay -> {
                errorMessage = "Delay must be more than $minDelay"
                status = CacheStatus.FAIL
                false
            }
            obj.delay > maxDelay -> {
                errorMessage = "Delay must be less than $maxDelay"
                status = CacheStatus.FAIL
                false
            }
            obj.queueName.isBlank() -> true
            obj.queueName !in allowedQueues -> {
                errorMessage = "Queue ${obj.queueName} is not among allowed queues: $allowedQueues"
                status = CacheStatus.FAIL
                false
            }
            else -> true
        }
    }

    private fun stubForGet(context: SkbCacheContext): Boolean = with(context) {
        when {
            stub.isBlank() -> false
            stub.contains("\\bok\\b".toRegex(RegexOption.IGNORE_CASE)) -> {
                obj = CacheObject(
                    data = "Stored value",
                    queueName = "stub-queue",
                    delay = Duration.ofSeconds(130)
                )
                status = CacheStatus.OK
                true
            }
            stub.contains("\\bnot[-_ ]found\\b".toRegex(RegexOption.IGNORE_CASE)) -> {
                obj = CacheObject.NONE
                status = CacheStatus.NOT_FOUND
                true
            }
            stub.contains("\\b(fail|error)\\b".toRegex(RegexOption.IGNORE_CASE)) -> {
                throw StubGeneratedException("Generated by stub exception")
            }
            else -> {
                obj = CacheObject.NONE
                status = CacheStatus.FAIL
                errorMessage = "Allowed values for stub are $STUB_GET_OK, $STUB_GET_NOT_FOUND, $STUB_GET_FAIL"
                true
            }
        }
    }

}
